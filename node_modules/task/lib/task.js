/*
 * task
 * http://github.com/node-task/task
 *
 * Copyright (c) 2012 Tyler Kellen, contributors
 * Licensed under the MIT license.
 */

'use strict';

var _ = require('lodash');
var util = require('util');
var when = require('when');
var extruder = require('extruder');
var EventEmitter2 = require('eventemitter2').EventEmitter2;

var Task = function Task (config) {
  this.emitter = new EventEmitter2({wildcard: true});
  _.extend.apply(this, arguments);
};

/**
  Convenience method to subclass Task.
*/
Task.extend = function (props) {
  var ctor = function ()  {
    Task.apply(this, arguments);
  };
  util.inherits(ctor, Task);
  _.extend(ctor.prototype, props);
  return ctor;
};

/**
  Handle thrown exceptions.
*/
Task.prototype.exception = function (message, exception) {
  console.log(message, exception);
};

/**
  Conveniently expose EventEmitter2.
*/
Task.prototype.emit = function () {
  this.emitter.emit.apply(this.emitter, arguments);
};

/**
  Main entry point for task.
*/
Task.prototype.run = function (config, input) {
  var self = this;
  var parsedConfig = self._parseConfig(config);
  var setup = self._setup(parsedConfig);
  var method = setup.then(function() {
    return self._method(parsedConfig, input);
  });
  var teardown = method.then(function() {
    return self._teardown(parsedConfig);
  });
  return teardown.then(function() {
    return method;
  }, this.exception);
};

/**
  Allow task to be chained cleanly
**/
Task.prototype.chain = function (config) {
  return function (input) {
    return this.run(config, input);
  }.bind(this);
};

/**
  Parse config to add defaults.

  Task writers may override this.
*/
Task.prototype.parseConfig = function (config) {
  var defaults = _.merge({}, this.options||{}, function(d, o) {
    return o.defaultValue;
  });
  return _.extend(defaults, config);
};


/**
  Use this to run pre-task stuff.
  Return a promise if async.

  Task writers may override this.
*/
Task.prototype.setup = function (config) {};

/*
  Task execution goes here.
  Return a promise if async.

  Task writers may override this.
**/
Task.prototype.method = function (config, input) {
  var self = this; // because promises don't have context
  if(input) {
    var processed = when(input);

    // if we have a mapping method, process all inputs with it
    if(_.isFunction(self.map)) {
      processed = extruder.map(input, function (source, dest) {
        return self.map(config, source, dest);
      }, self);
    }

    // if we have a reducing method, process all inputs with it
    if(_.isFunction(self.reduce)) {
      processed = processed.then(function (data) {
        return extruder.reduce(data, function (source, dest) {
          return self.reduce(config, source, dest);
        }, self);
      });
    }

    return processed;
  } else {
    return when(true);
  }
};

/*

Task.prototype.chain = function ()

/**
  Use this to run post-task stuff.
  Return a promise if async.

  Task writers may override this.
*/
Task.prototype.teardown = function (config) {};

/**
  Private methods to invoke task methods while emitting
  events and ensuring their results are promises.
*/
Task.prototype._parseConfig = function (config) {
  this.emit('debug.parseConfig', config);
  return this.parseConfig(config);
};
Task.prototype._setup = function (config) {
  this.emit('debug.setup', config);
  return when(this.setup(config));
};
Task.prototype._method = function (config, input) {
  this.emit('debug.method', config);
  return when(this.method(config, input));
};
Task.prototype._teardown = function (config) {
  this.emit('debug.teardown', config);
  return when(this.teardown(config));
};

module.exports = Task;